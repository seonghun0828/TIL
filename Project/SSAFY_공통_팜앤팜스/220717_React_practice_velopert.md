## 1. useMemo
특정 결과값을 재사용하기 위해 사용하는 hook이고 useEffect와 사용법이 비슷하다.   
첫번째 파라미터에는 어떻게 연산할지 정의하는 함수를 넣어주면 되고 두번째 파라미터에는 deps 배열을 넣어주면 된다.   
이 배열 안에 넣은 내용이 바뀌면, 등록한 함수를 호출해서 값을 연산해주고, 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 된다.

## 2. useCallback
특정 함수를 재사용하기 위해 사용하는 hook이고 useMemo를 기반으로 만들어졌기에 사용법이 동일하다.   
함수를 매 렌더링마다 재정의하지 않고 재사용하는 것은 컴포넌트 렌더링 최적화를 위해 필요하다.

## 3. React.memo를 사용한 컴포넌트 리렌더링 방지
컴포넌트를 React.memo( )로 감싸주면 props가 바뀔 때처럼 필요한 상황에서만 리렌더링이 일어나게 한다.   
그런데 useCallback의 deps로 설정되어 있는 값이 바뀔 때에도 불필요한 리렌더링이 일어날 수 있다.   
그럴 때에는 deps에서 그 값을 빼고 setState를 함수형 업데이트로 바꿔줌으로써 해결할 수 있다.   
   
setUsers(users.concat(user)) => setUsers(users => users.concat(user));

## 4. useReducer는 redux와 뭐가 다른가?
useReducer를 공부하며 사용법이 redux와 비슷하다는 것을 느꼈다.   
그래서 구글링 해보니 역시나 'useReducer와 redux 차이'라는 연관 검색어가 등장했다.   
   
useReducer만 사용해서는 비슷하기 힘들고, 보통 context API와 같이 사용하는 것과 redux를 비교했다.   
하지만 당연하게도 차이는 있었는데, 우선은 context API가 자주 변경되는 것이 아닌 전역 상태를 담는데 사용된다는 점이었다.   
   
문서에서 “context는 컴포넌트 재사용을 어렵게 만든다.” 라며, 최대한 사용을 줄이는 걸 권장한다.   
또한 개발자가 이를 세심히 다루지 않는다면, 불필요한 렌더링을 초래하기 쉽다고 경고한다.   
즉, 사용 목적 자체가 다른 것이다.   
   
또한 redux는 미들웨이라는 것이 있는데, 이것은 액션 객체가 리듀서에서 처리되기 전에 원하는 작업을 수행할 수 있게 해준다.   
보통 비동기 처리할 때 많이 사용된다고 한다.   
   
그럼에도 redux보다 useReducer + contextAPI를 사용해야 할 때가 있을 수 있다.   
redux를 만든 Dan Abramov도 사용해야만 해야 할 이유가 있을 때 redux를 사용하라고 한다.   
따로 설치가 필요하고, 러닝 커브도 꽤 있기 때문이다.    
모든 기술이 그렇듯이 관습적으로 사용하는 것을 지양하고, 충분히 고려해 사용을 결정하면 좋을 것이다.
