## 두 가지 웹 사이트 보안 공격
### 조사 동기
프로젝트를 시작하면서 유저 인증/인가 방식으로 JWT를 사용하기로 했다.   
검색해본 결과, 토큰은 refresh와 access로 나뉘는데 그것들을 저장하는 방식이나 위치가 제각각이었다.   

누구는 localStorage에, 누구는 쿠키에, 누구는 클라이언트 지역 변수에 저장했다.   
무엇이 보안적으로 더 안전할지 정확히 알고 결정해야 한다고 생각했고, 웹 사이트 보안 공격 XSS, CSRF에 대해 먼저 공부하게 되었다.   

### XSS(Cross-Site Scripting)
XSS(사이트 간 스크립팅)은 SQL injection과 함께 웹 상에서 가장 기초적인 취약점 공격 방법의 일종이다.   
악의적인 사용자가 공격하려는 사이트에 스크립트를 넣는 기법을 말하며,   
주로 다른 웹사이트와 정보를 교환하는 식으로 작동하므로 사이트 간 스크립팅이라고 명칭한다.   

웹 애플리케이션이 사용자로부터 입력 받은 값을 제대로 검사하지 않고 사용할 경우 나타나며,    
공격에 성공하면 사이트에 접속한 사용자는 삽입된 코드를 실행하게 된다.   

보통 의도치 않은 행동을 수행시키거나 쿠키나 세션 토큰 등의 민감한 정보를 탈취한다.   
여러 사용자가 접근 가능한 게시판 등에 코드를 삽입하는 경우도 많으며, 경우에 따라서는 메일, 심지어는 닉네임에 코드를 심기도 한다.   

### CSRF(Cross-Site Request Fogery)
사이트 간 요청 위조(또는 크로스 사이트 요청 위조, CSRF, XSRF)는 웹 사이트 취약점 공격의 하나로,    
사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격을 말한다.   
유명 경매 사이트인 옥션에서 발생한 개인정보 유출 사건에서 사용된 공격 방식 중 하나다.   
 
XSS가 사용자가 특정 웹사이트를 신용하는 점을 노린 것이라면, CSRF는 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 상태를 노린 것이다.    
일단 사용자가 웹사이트에 로그인한 상태에서 사이트간 요청 위조 공격 코드가 삽입된 페이지를 열면,    
공격 대상이 되는 웹사이트는 위조된 공격 명령이 믿을 수 있는 사용자로부터 발송된 것으로 판단하게 되어 공격에 노출된다.   

CSRF는 공격자가 사용자의 컴퓨터를 감염시키거나 해킹을 해서 이뤄지는 것이 아니므로 공격이 성공하려면 다음 조건을 만족해야 한다.   
1. 위조 요청을 전송하는 서비스(ex : 페이스북)에 희생자가 로그인 상태여야함.   
2. 희생자는 공격자가 만든 피싱 사이트에 접속해야함.   

## JWT를 어디에 저장해야 하는가?
### 각 저장 매체에 대한 고찰
프로젝트를 진행하며 토큰을 저장할 수 있는 매체에는 로컬스토리지, 쿠키 등이 있다.   
그렇다면 어느 곳이 안전하고 어느 곳이 위험한 저장 공간일까?   

#### 1. 로컬스토리지
브라우저 저장소에 저장하는 방식이다. Javascript 내 글로벌 변수로 읽기 / 쓰기 접근이 가능하다.   

##### 취약점
localStorage 안에 토큰을 저장해두면 XSS 공격을 통해 그 안에 담긴 값을 불러오거나, 불러온 값을 이용해 API 콜을 위조할 수 있다.   

#### 2. 쿠키
브라우저에 쿠키로 저장되는데, 클라이언트가 HTTP 요청을 보낼 때마다 자동으로 쿠키가 서버에 전송된다.    

##### 취약점
1. 쿠키도 로컬스토리지와 마찬가지로 Javascript 내 글로벌 변수로 읽기 / 쓰기 접근이 가능해 XSS 공격에 취약하다   

2. 또한, 쿠키에 토큰을 저장해 인증에 이용하는 구조에 CSRF 취약점이 있다면 인증 정보가 쿠키에 담겨 서버로 보내진다.    
그러므로 공격자는 유저 권한으로 정보를 가져오거나 액션을 수행할 수 있다.   

하지만 이 두 취약점을 가려줄 보완 방법 존재한다.   

##### 보완 방법
1. 쿠키에 httpOnly 옵션을 설정하면 Javascript로 접근이 불가능해져 XSS 공격에 방어할 수 있다.   

2. 쿠키에 refreshToken만 저장하고 새로운 accessToken을 받아와 인증에 이용하는 구조에서는 CSRF 취약점 공격을 방어할 수 있다.   
refreshToken으로 accessToken을 받아도 accessToken을 스크립트에 삽입할 수 없다면 토큰을 사용해 유저 정보를 가져올 수 없기 때문이다.   
또 accessToken을 클라이언트 지역 변수에 담으면 XSS 공격도 방어할 수 있다.   

## 결론
웹 사이트 보안 공격을 막기 위해 refresh(Token 생략)는 쿠키에, access는 클라이언트 지역 변수에 담는 것이 최선이라 생각된다.   
인증/인가 로직은 다음과 같다.   

1. 로그인에 성공하면 서버는 refresh를 쿠키에 담아 보내준다. 여기서 httpOnly 옵션을 추가해 XSS 공격을 방어한다.   
2. access를 response body에 담아 보내면 클라이언트에서 받아 지역 변수에 저장한다.   
3. 인가가 필요한 api 콜을 요청할 때 axios에 access를 담아 요청을 보낸다.   
4. access가 만료될 때 refresh를 담은 쿠키로 reissue api 콜을 요청하면 서버는 access를 보내준다.   

### 유의할 점
access의 유효기간은 5 ~ 15분으로 짧게 잡는 것이 좋다. 혹시 탈취를 당하더라도 최소한의 시간만 노출되게 하기 위해서다.   
보안을 위해 access 유효기간을 과도하게 짧게 설정하면 빈번한 reissue로 인한 트래픽 과부하가 생길 수 있기에 상황에 맞게 설정한다.

[참고1](https://lucete1230-cyberpolice.tistory.com/23)   
[참고2](https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0)   
