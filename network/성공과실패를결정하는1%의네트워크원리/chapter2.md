# TCP/IP의 데이터를 전기 신호로 만들어 보낸다

[1. 소켓을 작성한다](#1-소켓을-작성한다)   
[2. 서버에 접속한다](#2-서버에-접속한다)   
[3. 데이터를 송∙수신한다](#3-데이터를-송수신한다)   
[4. 서버에서 연결을 끊어 소켓을 말소한다](#4-서버에서-연결을-끊어-소켓을-말소한다)   
[5. IP와 이더넷의 패킷 송∙수신 동작](#5-ip와-이더넷의-패킷-송수신-동작)   
[6. UDP 프로토콜을 이용한 송∙수신 동작](#6-udp-프로토콜을-이용한-송수신-동작)   

## 1 소켓을 작성한다
    1. 프로토콜 스택의 내부 구성
프로토콜 스택은 TCP, UDP, IP로 이뤄진다.   
TCP : 일반 애플리케이션 데이터 송수신   
UDP : DNS 서버 조회 등 짧은 제어용 데이터 송수신   
IP : 패킷으로 데이터를 나눠 이것을 통신 상대까지 운반   

    2. 소켓의 실체는 통신 제어용 제어 정보
프로토콜 스택은 내부에 메모리 영역을 가지고 제어 정보를 기록합니다   
제어 정보에는 통신 상대의 IP 주소, 포트 번호, 통신 동작의 진행 상태 등이 있다   
프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 움직인다

    3. Socket을 호출했을 때의 동작
애플리케이션이 socket을 호출하면 프로토콜 스택은 메모리 영역을 확보해 소켓을 만든다.   
아직 초기 상태라는 것을 이 영역에 기록한다.   
소켓을 만든 후 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다.

## 2 서버에 접속한다
    1. 접속의 의미
소켓은 만든 직후 애플리케이션은 connect를 호출. 접속 동작 시작   
접속 동작은 우선 통신 상대와 제어 정보(IP 주소, 포트 번호 등)를 주고 받는 것으로 시작함.    
데이터 송수신 동작에서 송수신하는 데이터를 일시적으로 저장하는 메모리 영역을 '버퍼 메모리'라고 함.   
접속 동작을 할 때 버퍼 메모리를 확보함.

    2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다
제어 정보에는 1) 클라이언트와 서버가 서로 연락하기 위해 주고 받는 제어 정보와   
2) 소켓에 기록하여 프로토콜 스택의 동작을 제어하는 제어 정보가 있다.   
   
1)은 통신 동작 전체에서 필요한 정보, 클라이언트와 서버 사이 주고 받는 패킷의 맨 앞부분에 부가함.   
이것을 _**헤더**_ 라고 부름. TCP 헤더, 이더넷 헤더, IP 헤더 등 무엇의 헤더인지를 써야 함.   
클라이언트와 서버는 헤더에 필요한 정보를 기록, 연락하며 통신 동작을 진행함.   
데이터를 저장한 패킷의 맨 앞부분이 헤더.   
제어 동작이나 연결 끊기 동작 등 데이터가 없는 경우 제어 정보만 주고 받음. 즉 헤더만 주고 받음.   
   
2)에는 앱에서 통지된 정보, 통신 상대로부터 받은 정보, 진행 상황 등이 수시로 기록.  
프로토콜 스택이 하나하나 정보를 참조하면서 움직이므로 소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화 되어 있다 해도 무방.   
클라이언트와 서버는 헤더의 제어 정보 만으로 연락이 가능하므로 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음.   
OS가 다르면 프로토콜 스택 만드는 방법이 달라 제어 정보도 다르지만 통신하는데는 문제가 없는 것.   

    3. 접속 동작의 실제
송신처와 수신처의 포트 번호를 통해 송신처와 수신처의 소켓을 지정할 수 있음.   
지정했으면 컨트롤 비트인 SYN 라는 비트를 1로 만듦.   
   
connect를 호출하면 제어 정보가 프로토콜 스택 TCP 부분 -> IP 부분 -> 네트워크 (패킷 형태로 이동) ->   
서버 측 IP 담당 부분 -> 서버 TCP 부분에 제어 정보 도착하면 TCP 헤더를 조사, 포트 번호에 해당하는 소켓을 발견 ->   
여기에 필요한 정보를 기록, 접속 동작을 진행 중 상태로 바꾸고 다시 응답을 클라이언트로 반송   
   
서버도 송신처와 수신처의 포트 번호, SYN 비트 등을 설정한 TCP 헤더를 만들고, _**ACK**_ 라는 컨트롤 비트도 1로 만듦.   
ACK를 1로 만드는 것은 패킷을 받은 것을 알리기 위한 동작. TCP  헤더를 IP 담당 부분에게 건네주어 클라이언트에 전송   
   
패킷이 IP 부분을 경유해 TCP 부분 도착. TCP 헤더 조사.   
SYN이 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 접속 완료를 나타내는 제어 정보를 소켓에 기록.   
패킷 무사 도착을 서버에 알리기 위해 ACK를 1로 만든 TCP 헤더를 서버에 반송. 서버에 도착하면 접속 동작의 대화 끝.  
   
이제 소켓은 데이터를 송수신할 수 있는 상태. chapter1에서의 파이프 연결 비유가 이 상태인 것.   
이 상태를 커넥션 혹은 세션이라고 함. 세션이 만료되었습니다 할 때의 그 세션인 것 같음.   
close를 호출해 연결을 끊을 때까지 계속 존재함.

## 3 데이터를 송수신한다
    1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다
데이터 송수신 동작은 앱이 write을 호출해 송신 데이터를 프로토콜 스택에 건네주며 시작.   
프로토콜 스택은 우선 내부 버퍼 메모리 영역에 받은 데이터를 저장. 데이터의 길이는 앱의 사정에 따라 달라짐.   
어느 정도의 데이터를 저장하고 나서 송수신 동작을 할 지는 두 요소를 바탕으로 판단.   
    
1번) 한 패킷에 저장할 수 있는 데이터의 크기.   
MTU : 한 패킷으로 운반할 수 있는 데이터의 최대 길이, 이더넷에서 보통 1,500 byte   
MSS : MTU에서 헤더를 제외한 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이   
   
2번) 타이밍.   
프로토콜 스택 안에 타이머가 일정 시간 이상 경과하면 패킷을 송신.   
MSS에 가깝게 저장하는 대신 느리게 송신할지, 데이터가 덜 모여도 시간이 지나면 송신할지는 trade-off

    2. 데이터가 클 때는 분할하여 보낸다
송신 버퍼에 저장된 데이터가 MSS 길이를 초과하면 MSS 크기에 맞게 분할해 패킷에 넣어 송신   
데이터 조각 앞에 TCP 헤더 추가, 소켓에 기록된 제어 정보를 바탕으로 IP 헤더 추가해 송신

    3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다
TCP는 송신한 패킷이 상대에게 도착하지 않았으면 다시 송신하는 기능 존재하므로 송신 확인이 필수   
데이터 조각의 맨 앞부터 세어 1byte로 시작. 시퀀스 번호는 1, 크기 1,460byte면 ACK 번호는 1,461   
다음 시퀀스 번호는 1,461이고 크기는 1,460byte, ACK번호는 2,921   
이런 식으로 시퀀스 번호와 ACK 번호를 설정   
수신 측은 시퀀스 번호가 누락 없으면 몇 번째 byte까지 수신했는지를 ACK 번호로 기록해 송신측에 알려줌.   
   
<접속 동작>   
   
실제로는 시퀀스 번호가 1부터 시작하지 않고 해킹 방지 차원에서 난수를 바탕으로 초기값 설정.   
접속 동작 부분에서 클라이언트가 SYN 제어 비트를 1로 하여 서버에 보낼 때 시퀀스 초기값도 같이 보냄 ->   
서버는 시퀀스 초기값으로부터 산출한 ACK 번호와 서버 측 시퀀스 초기값을 보냄 ->   
클라이언트는 도착을 알리는 ACK 번호를 보내며 접속 동작 마무리   
   
<송수신 동작> : 본래 송수신 동작은 양방향이지만 브라우저에서는 클라이언트가 먼저 보내야 시작   
   
클라이언트가 시퀀스 번호와 데이터를 보낸다 ->   
서버는 송신 확인의 ACK 번호를 반송한다 ->   
...   
서버에서도 시퀀스 번호와 데이터를 클라이언트에 보내면 ->   
클라이언트는 송신 확인의 ACK 번호를 반송한다   

    4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
ACK 번호가 돌아오기를 기다리는 시간을 '타임아웃 값'이라고 한다.   
이 값은 패킷의 평균 왕복 시간을 토대로 동적으로 조정한다.   
왕복 시간이 지연되면 대기 시간도 늘리고, 곧바로 돌아오면 대기 시간도 짧아진다.  

    5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
한 개의 패킷을 보내고 ACK 번호를 기다리는 것은 시간 낭비이므로 윈도우 제어 방식을 사용.   
ACK 번호를 기다리지 않고 수신 측의 능력을 감안해 차례로 패킷을 보냄.  
수신 측에서 송신측에 수신 가능한 데이터 양을 통지. 이것을 윈도우 사이즈라고 부름.   
   
윈도우 사이즈가 4,380byte라고 통지하면 송신측은 그 값을 저장   
송신측이 데이터를 1,460byte 보내면 현재 윈도우 사이즈에 그 값을 뺀 2,920을 저장   
윈도우 사이즈가 0이 되면 송신 중지   
   
수신 측에서 2,900 byte만큼 데이터를 추출해 수신 버퍼에 빈 부분이 생기면    
그 분량만큼 TCP 헤더의 윈도우 필드에 이 값을 알림. 윈도우 사이즈는 2,920이 됨.  
다시 데이터 송신 시작.

    6. ACK 번호와 윈도우를 합승한다
윈도우 통지와 ACK 번호 통지는 한 패킷에 합승시켜 패킷 수를 줄일 수 있다.   
ACK 번호 통지가 연속으로 일어나는 경우 최후의 것만 통지해 패킷 수를 줄일 수도 있다.   
마찬가지로 윈도우 통지의 연속도 최후의 것만 통지할 수 있다.

    7. HTTP 응답 메시지를 수신한다
브라우저의 리퀘스트 메시지 송신 의뢰가 끝나면 서버에서 돌아오는 응답 메시지를 받기 위해 read 프로그램을 호출한다.   
메시지 수신 동작은 데이터 송신과 거의 유사.

## 4 서버에서 연결을 끊어 소켓을 말소한다
    1. 데이터 보내기를 완료했을 때 연결을 끊는다
데이터 보내기를 완료한 쪽(서버 측이라고 가정)에서 연결 끊기 단계에 들어가기 위해 Socket의 close를 호출 ->   
프로토콜 스택이 TCP 헤더를 만들고 컨트롤 비트의 FIN 비트를 1로 설정해 송신. 서버 측 소켓에 연결 끊기 동작 기록 ->   
FIN이 1인 TCP 헤더가 도착하면 클라이언트 소켓에 연결 끊기 기록. 패킷 수신 알리기 위해 ACK 번호 반송 ->   
클라이언트 앱이 read 호출해 데이터를 가지러 오면 데이터 대신 서버가 보낸 데이터 수신 완료 사실을 알림 ->   
클라이언트도 close 호출, FIN 1 TCP 헤더 서버에 송신. 서버에서 ACK 번호 돌아오면 통신 끝.    

    2. 소켓을 말소한다
오동작을 막기 위해 일정 시간이 지난 후 소켓을 말소한다.

    3. 데이터 송수신 동작을 정리한다
접속 동작 -> 송수신 동작 -> 연결 끊기 동작 순으로 TCP 프로토콜에서 애플리케이션의 데이터 송수신 과정이 끝난다.
## 5 IP와 이더넷의 패킷 송수신 동작
    1. 패킷의 기본
패킷은 헤더와 데이터 두 부분으로 구성. 헤더에는 수신처를 나타내는 주소 등의 제어 정보, 데이터는 내용물   
패킷을 주고 받는 송신처와 수신처는 자주 입장이 바뀌기 때문에 명확히 구별하지 않고 '엔드노드'라고 부른다.   
   
패킷의 기본은 여러 패킷 통신 방식에 적합하다. TCP/IP는 기본에서 발전한 단계로,   
'라우터'와 '허브'라는 패킷 중계 장치에서 역할을 분담하며 패킷을 운반하기 때문이다.   
   
1번) 라우터가 목적지를 확인하여 다음 라우터를 나타낸다 => MAC 헤더(이더넷용 헤더)   
2번) 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착한다 => IP 헤더(IP용 헤더)   
   
MAC 헤더는 라우터에 도착할 때마다 다음 라우터의 MAC 주소를 바꿔 써주고    
IP 헤더는 처음 송신처의 목적지 IP를 기록하면 변경할 일이 없다.   

    2. 패킷 송수신 동작의 개요
IP는 패킷을 들여다 보지 않고 그 앞에 IP 헤더와 MAC 헤더를 추가한다.   
그러므로 패킷을 송수신하는 동작은 패킷의 역할에 상관 없이 모두 같다.   
송신할 때는 TCP -> IP(두 헤더를 붙임) -> LAN 어댑터(이더넷)이고 수신할 때는 역순이다.

    3. 수신처 IP 주소를 기록한 IP 헤더를 만든다
IP 헤더의 제어 정보는 1)수신처 IP 주소를 설정하는데 가장 중요하다. 스스로 판단하지 않고 앱이 TCP에 통지한 그대로 사용한다.   
2)송신처 IP 주소도 설정한다. 그러나 해당 송신처에 할당된 LAN 어댑터가 여러 개면 주소도 여러개이므로 판단해야 한다.   
라우터의 IP용 표, 경로표 또는 라우팅 테이블이라고 부르는 것을 사용해 IP 헤더의 송신처 IP 주소를 설정한다.   
3)프로토콜 번호라는 필드에도 값을 설정한다. 패킷의 내용물이 어디에서 의뢰받은 것인지 나타낸다.   
TCP에서 의뢰받았으면 06(16진수), UDP이면 17(16진수)이라는 식이다.

    4. 이더넷용 MAC 헤더를 만든다
이더넷은 TCP/IP 개념이 통용되지 않아 다른 구조로 패킷의 수신처를 파악한다. 그 때 사용하는 것이 MAC 헤더.   
MAC 헤더에는 수신처 MAC 주소, 송신처 MAC 주소, 이더 타입이 기록되어 있다.   
MAC 주소는 IP(32bit) 주소와는 다르게 48bit이다. 또 주소의 개념이 아니고 48bit를 하나의 값으로 생각한다.   
   
   
이더 타입은 IP 헤더의 프로토콜 번호와 비슷하다. 이더넷의 경우 이더 타입까지가 MAC 헤더이고 그 뒤로는 패킷의 내용물이라 생각한다.   
그 내용물이 무엇인지 이더 타입으로 나타낸다. IP 프로토콜은 0800(16진 표기), ARP 프로토콜은 0806(16진)의 식이다.   
송신처 MAC 주소는 LAN 어댑터의 MAC 주소를 설정한다. 여러 LAN 어댑터가 있을 때는 여러개 중 하나의 어댑터를 정하고 그 MAC 주소를 설정한다.   
수신처 MAC 주소는 다소 복잡하다. 패킷을 건네주게 될 상대의 MAC 주소를 기록해야 하는데 누구에게 건네줄 지 모르기 때문에 우선 상대를 찾아야 한다.

    5. ARP로 수신처 라우터의 MAC 주소를 조사한다
이더넷에는 연결돼 있는 전원에게 패킷을 전달하는 브로드캐스트라는 구조가 있어 이 구조를 이용해 수신 IP 주소를 가지고 있는 상대의 MAC 주소를 알아낸다.   
한 번 조사한 결과는 ARP 캐시에 저장해 패킷을 보낼 때 여기를 먼저 조사하고 없는 경우에만 ARP를 조회한다.   
MAC 주소를 MAC 헤더에 설정해 MAC 헤더를 만들고 IP 헤더 앞에 붙여 패킷을 완성시킨다. 여기까지가 IP 담당 뿐의 역할.

    6. 이더넷의 기본
이더넷은 다수의 컴퓨터가 여러 상대와 적은 비용으로 통신하는 통신 기술. 컴퓨터가 신호를 송신하면 케이블을 통해 네트워크 전체에 신호가 흐른다.   
신호에 해당하는 기기는 패킷을 수신하고 나머지는 패킷을 폐기하는 방식. 아래의 세 가지 성질을 가진 것이 이더넷이다.   
MAC 헤더의 수신처 MAC 주소에 기억된 상대에게 패킷을 전달, 송신처 MAC 주소로 송신처를 나타낸 후 이더 타입으로 패킷의 내용물을 나타낸다.   

    7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다
LAN 어댑터가 IP가 만든 패킷을 전기나 빛의 신호로 변환하여 송신하는 동작을 실행한다. LAN 어댑터는 LAN 드라이버 소프트웨어가 제어한다.   
LAN 어댑터는 전원을 공급해 OS가 작동될 때 LAN 드라이버가 하드웨어 초기화 작업을 수행해야 사용 가능 상태가 된다.   
하드웨어 기초 검사 이외에 이더넷의 송수신 동작을 제어하는 MAC 회로에 MAC 주소를 설정하는 것도 포함된다.   
LAN 어댑터의 ROM에는 전세계적으로 중복되지 않도록 제조 시 MAC 주소가 기록되는데 LAN 드라이버가 이것을 읽어와 MAC 회로에 설정하는 것이다.   


    8. 패킷에 3개의 제어용 데이터를 추가한다
LAN 드라이버는 패킷을 LAN 어댑터의 버퍼 메모리에 복사한다. 그 후 MAC 회로에 명령을 보내면 송신 작업을 시작한다.   
MAC 회로는 버퍼 메모리에서 패킷을 추출해 맨 앞에는 프리앰블, 스타트 프레임 딜리미터를, 맨 끝에는 프레임 체크 시퀀스(FCS)를 부가한다.   
프리앰블은 송신 패킷을 읽을 때 타이밍을 잡기 위한 것으로 1010...이 번갈아 나타나는 56비트의 데이터이다.   
   
신호 값을 읽을 때 1이나 0이 이어지면 신호의 변화가 없어 비트 구분이 불가능하기 때문에 비트 구분을 나타내는 '클록'이라는 신호를 같이 보낸다.   
갑자기 패킷의 신호를 흘리지 않고 클록 신호의 타이밍을 잡기 위한 알림 신호가 프리 앰블인 것이다.   
   
스타트 프레임 딜리미터는 마지막 비트 패턴이 다르기 때문에 이 다음 비트부터 데이터를 추출해 읽으면 된다고 안내해주는 신호이다.   
   
FCS는 패킷을 운반하는 도중 파형이 흐트러져 데이터가 변한 경우 검출을 위해 사용한다.

    9. 허브를 향해 패킷을 송신한다
위의 세 가지를 부가하면 케이블에 송출할 패킷이 완성된다. 리피터 허브나 스위칭 허브를 사용할 수 있는데 요즘은 스위칭 허브만 사용한다.   
스위칭 허브는 전이중 모드를 사용하는데 충돌이 일어나지 않는다. 리피터 허브를 사용하면 반이중 모드로 송신하는데 충돌이 발생할 수 있다.   
   
반이중 모드는 신호의 충돌을 피하기 위해 케이블에 다른기기가 송신한 신호가 흐르고 있는지 조사하고 없을 때 신호를 보낸다.   
MAC 회로는 프리앰블부터 1비트씩 차례로 디지털 데이터를 어느 형식으로도 변경할 수 있는 공통 형식의 전기 신호로 변환한다.    
변환한 공통 형식의 신호를 PHY 또는 MAU라는 송수신 신호 부분에 보내는데 이때 디지털 데이터를 신호로 변환하는 속도를 전송 속도라고 하는 것.   
PHY(MAU) 회로는 이 신호를 케이블에 송출하는 형식으로 변환하여 송신한다. 즉 PHY(MAU)회로는 MAC 회로의 송신 신호를 변환하는 변환 회로.
   
PHY(MAU) 회로는 변환한 신호를 케이블에 송신하는데, 이 때 수신 신호선에서 신호가 흘러들어오는지도 감시한다.   
수신 신호가 흐르지 않는 것을 파악한 이후 송신을 시작하지만 만에 하나의 확률로 동시에 송신한 기기가 있으면 수신선으로 신호가 흘러 들어온다.   
이 경우 신호가 뒤섞여 충돌이 나며 송신을 중지한다. 이 사실을 알리기 위해 재밍 신호라는 신호를 잠시 흘리고 나서 잠깐 대기 후 다시 송신한다.   
난수를 생성해 그만큼 대기 후 송신하게 되는데 혹시 또 겹치면 시간을 2배 늘려 대기한다. 열 번째까지도 실패한다면 오류로 판단한다.

    10. 돌아온 패킷을 받는다
리피터 허브라면 반이중 동작의 이더넷에서는 1대가 송신한 신호가 리피터 허브에 접속된 케이블 전부에 흘러간다.   
수신한 신호의 맨 앞 프리앰블의 파형에서 타이밍을 계산해 스타트 프레임 딜리미터가 나오면 그 다음 비트부터 디지털 데이터로 변환해 동작을 개시한다.   
PHY(MAU) 회로에서 신호를 공통 형식으로 변환해 MAC 회로에 보내면, MAC 회로는 신호를 맨 앞부터 차례대로 버퍼 메모리에 저장한다.   
마지막에 FCS를 검사하고 오류가 있으면 폐기한다. 문제 없으면 MAC 헤더의 수신처 MAC 주소를 조사해 LAN 어댑터를 초기화할 때 설정한   
자체 MAC 주소와 비교한 후 자신에게 오는 것이 맞으면 패킷을 받아 버퍼 메모리에 저장한다. 그 후 컴퓨터 본체에 통지한다.   
   
이 통지는 '인터럽트'라는 구조를 사용한다. LAN 어댑터가 인터럽트를 CPU에 보내면 CPU가 LAN 드라이버를 호출해 LAN 어댑터를 제어하는 것이다.   
LAN 드라이버가 동작해 LAN 어댑터의 버퍼 메모리에서 패킷을 추출하면, LAN 드라이버는 MAC 헤더의 타입 필드 값으로부터 프로토콜을 판별한다.   
현재는 대부분 TCP/IP를 사용하지만 예전에는 AppleTalk 등 다른 프로토콜이 있었다. 해당하는 프로토콜의 프로토콜 스택에게 패킷을 건네준다.

    11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다
IP 담당 부분은 IP 헤더를 조사해 포맷을 확인하고 수신처 IP 주소를 조사한다.   
IP가 다르면 IP 담당 부분이 ICMP라는 메시지를 사용해 상대에게 오류를 통지한다.   
   
수신처 IP 주소가 올바르면 조각 나누기(fragmentation)을 통해 나눠진 패킷을 원래대로 되돌린다.   
같은 ID 정보를 가진 패킷을 리어셈블링(reassembling)을 통해 합치고 패킷을 TCP 담당 부분에 건네준다.
   
TCP 담당 부분은  IP 헤더에 기록된 수신처와 송신처 IP 주소, TCP 헤더에 기록된 수신처와 송신처 포트 번호를 조사해 해당 소켓을 찾는다.   
해당 소켓을 찾아내면 통신 진행 상태가 기록되어 있으므로 상황에 따라 적절한 동작을 실행한다.
## 6 UDP 프로토콜을 이용한 송수신 동작
    1. 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다
TCP가 아닌 UDP 프로토콜을 사용해 데이터를 송수신 하는 앱도 있다. ex) DNS 서버에 IP 주소를 조회할 때   
TCP는 오류로 도착하지 않은 패킷만 다시 보내는 구조인데, 이는 매우 복잡하다.   
UDP는 데이터가 한 패킷에 들어갈 만큼 짧기 때문에 오류로 도착하지 않으면 통째로 다시 보내도 효율적이기에 그렇게 한다.   
데이터를 보내면 보통 회신이 돌아오므로 접속하거나 연결을 끊을 때의 제어용 패킷을 보낼 필요도 없다.

    2. 제어용 짧은 데이터
UDP로 송신할 때는 앱에서 송신 데이터를 받으면 여기에 UDP 헤더만 부가해 IP에 의뢰해 송신하기만 하면 된다.   
수신 시에는 IP 헤더에 기록돼 있는 수신처, 송신처 IP 주소와 UDP 헤더에 기록돼 있는 수신처, 송신처 포트 번호만 있으면 된다.   
이 네 항목과 소켓에 기록된 정보를 결합해 데이터를 건네줄 대상 앱을 판단하고 여기에 데이터를 건네주기만 하면 된다.   
만약 오류가 발생해도 무시한다. 회답이 돌아오지 않을 때 한번 더 보내면 그만이기 때문이다.

    3. 음성 및 동영상 데이터
TCP처럼 특정 부분을 수신하지 못했다고 다시 수신하면 음성이나 영상은 재생 타이밍이 안맞으면 원래대로 되돌릴 수 없다.   
그러나 음성과 영상의 특성 상 데이터도 다소 없어도 지직 거리고 말기 때문에 허용할 수 있는 수준이다.   
그러므로 UDP로 한 번에 보내는 것이 더 효율적이다.
