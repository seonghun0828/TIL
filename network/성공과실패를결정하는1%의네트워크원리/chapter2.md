# TCP/IP의 데이터를 전기 신호로 만들어 보낸다

[1. 소켓을 작성한다](#1-소켓을-작성한다)   
[2. 서버에 접속한다](#2-서버에-접속한다)   
[3. 데이터를 송∙수신한다](#3-데이터를-송수신한다)   
[4. 서버에서 연결을 끊어 소켓을 말소한다](#4-서버에서-연결을-끊어-소켓을-말소한다)   
[5. IP와 이더넷의 패킷 송∙수신 동작](#5-ip와-이더넷의-패킷-송수신-동작)   
[6. UDP 프로토콜을 이용한 송∙수신 동작](#6-udp-프로토콜을-이용한-송수신-동작)   

## 1 소켓을 작성한다
    1. 프로토콜 스택의 내부 구성
프로토콜 스택은 TCP, UDP, IP로 이뤄진다.   
TCP : 일반 애플리케이션 데이터 송수신   
UDP : DNS 서버 조회 등 짧은 제어용 데이터 송수신   
IP : 패킷으로 데이터를 나눠 이것을 통신 상대까지 운반   

    2. 소켓의 실체는 통신 제어용 제어 정보
프로토콜 스택은 내부에 메모리 영역을 가지고 제어 정보를 기록합니다   
제어 정보에는 통신 상대의 IP 주소, 포트 번호, 통신 동작의 진행 상태 등이 있다   
프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 움직인다

    3. Socket을 호출했을 때의 동작
애플리케이션이 socket을 호출하면 프로토콜 스택은 메모리 영역을 확보해 소켓을 만든다.   
아직 초기 상태라는 것을 이 영역에 기록한다.   
소켓을 만든 후 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다.

## 2 서버에 접속한다
    1. 접속의 의미
소켓은 만든 직후 애플리케이션은 connect를 호출. 접속 동작 시작   
접속 동작은 우선 통신 상대와 제어 정보(IP 주소, 포트 번호 등)를 주고 받는 것으로 시작함.    
데이터 송수신 동작에서 송수신하는 데이터를 일시적으로 저장하는 메모리 영역을 '버퍼 메모리'라고 함.   
접속 동작을 할 때 버퍼 메모리를 확보함.

    2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다
제어 정보에는 1) 클라이언트와 서버가 서로 연락하기 위해 주고 받는 제어 정보와   
2) 소켓에 기록하여 프로토콜 스택의 동작을 제어하는 제어 정보가 있다.   
   
1)은 통신 동작 전체에서 필요한 정보, 클라이언트와 서버 사이 주고 받는 패킷의 맨 앞부분에 부가함.   
이것을 _**헤더**_ 라고 부름. TCP 헤더, 이더넷 헤더, IP 헤더 등 무엇의 헤더인지를 써야 함.   
클라이언트와 서버는 헤더에 필요한 정보를 기록, 연락하며 통신 동작을 진행함.   
데이터를 저장한 패킷의 맨 앞부분이 헤더.   
제어 동작이나 연결 끊기 동작 등 데이터가 없는 경우 제어 정보만 주고 받음. 즉 헤더만 주고 받음.   
   
2)에는 앱에서 통지된 정보, 통신 상대로부터 받은 정보, 진행 상황 등이 수시로 기록.  
프로토콜 스택이 하나하나 정보를 참조하면서 움직이므로 소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화 되어 있다 해도 무방.   
클라이언트와 서버는 헤더의 제어 정보 만으로 연락이 가능하므로 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음.   
OS가 다르면 프로토콜 스택 만드는 방법이 달라 제어 정보도 다르지만 통신하는데는 문제가 없는 것.   

    3. 접속 동작의 실제
송신처와 수신처의 포트 번호를 통해 송신처와 수신처의 소켓을 지정할 수 있음.   
지정했으면 컨트롤 비트인 SYN 라는 비트를 1로 만듦.   
   
connect를 호출하면 제어 정보가 프로토콜 스택 TCP 부분 -> IP 부분 -> 네트워크 (패킷 형태로 이동) ->   
서버 측 IP 담당 부분 -> 서버 TCP 부분에 제어 정보 도착하면 TCP 헤더를 조사, 포트 번호에 해당하는 소켓을 발견 ->   
여기에 필요한 정보를 기록, 접속 동작을 진행 중 상태로 바꾸고 다시 응답을 클라이언트로 반송   
   
서버도 송신처와 수신처의 포트 번호, SYN 비트 등을 설정한 TCP 헤더를 만들고, _**ACK**_ 라는 컨트롤 비트도 1로 만듦.   
ACK를 1로 만드는 것은 패킷을 받은 것을 알리기 위한 동작. TCP  헤더를 IP 담당 부분에게 건네주어 클라이언트에 전송   
   
패킷이 IP 부분을 경유해 TCP 부분 도착. TCP 헤더 조사.   
SYN이 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 접속 완료를 나타내는 제어 정보를 소켓에 기록.   
패킷 무사 도착을 서버에 알리기 위해 ACK를 1로 만든 TCP 헤더를 서버에 반송. 서버에 도착하면 접속 동작의 대화 끝.  
   
이제 소켓은 데이터를 송수신할 수 있는 상태. chapter1에서의 파이프 연결 비유가 이 상태인 것.   
이 상태를 커넥션 혹은 세션이라고 함. 세션이 만료되었습니다 할 때의 그 세션인 것 같음.   
close를 호출해 연결을 끊을 때까지 계속 존재함.

## 3 데이터를 송수신한다
    1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다
데이터 송수신 동작은 앱이 write을 호출해 송신 데이터를 프로토콜 스택에 건네주며 시작.   
프로토콜 스택은 우선 내부 버퍼 메모리 영역에 받은 데이터를 저장. 데이터의 길이는 앱의 사정에 따라 달라짐.   
어느 정도의 데이터를 저장하고 나서 송수신 동작을 할 지는 두 요소를 바탕으로 판단.   
    
1번) 한 패킷에 저장할 수 있는 데이터의 크기.   
MTU : 한 패킷으로 운반할 수 있는 데이터의 최대 길이, 이더넷에서 보통 1,500 byte   
MSS : MTU에서 헤더를 제외한 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이   
   
2번) 타이밍.   
프로토콜 스택 안에 타이머가 일정 시간 이상 경과하면 패킷을 송신.   
MSS에 가깝게 저장하는 대신 느리게 송신할지, 데이터가 덜 모여도 시간이 지나면 송신할지는 trade-off

    2. 데이터가 클 때는 분할하여 보낸다
송신 버퍼에 저장된 데이터가 MSS 길이를 초과하면 MSS 크기에 맞게 분할해 패킷에 넣어 송신   
데이터 조각 앞에 TCP 헤더 추가, 소켓에 기록된 제어 정보를 바탕으로 IP 헤더 추가해 송신

    3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다
TCP는 송신한 패킷이 상대에게 도착하지 않았으면 다시 송신하는 기능 존재하므로 송신 확인이 필수   
데이터 조각의 맨 앞부터 세어 1byte로 시작. 시퀀스 번호는 1, 크기 1,460byte면 ACK 번호는 1,461   
다음 시퀀스 번호는 1,461이고 크기는 1,460byte, ACK번호는 2,921   
이런 식으로 시퀀스 번호와 ACK 번호를 설정   
수신 측은 시퀀스 번호가 누락 없으면 몇 번째 byte까지 수신했는지를 ACK 번호로 기록해 송신측에 알려줌.   
   
<접속 동작>   
   
실제로는 시퀀스 번호가 1부터 시작하지 않고 해킹 방지 차원에서 난수를 바탕으로 초기값 설정.   
접속 동작 부분에서 클라이언트가 SYN 제어 비트를 1로 하여 서버에 보낼 때 시퀀스 초기값도 같이 보냄 ->   
서버는 시퀀스 초기값으로부터 산출한 ACK 번호와 서버 측 시퀀스 초기값을 보냄 ->   
클라이언트는 도착을 알리는 ACK 번호를 보내며 접속 동작 마무리   
   
<송수신 동작> : 본래 송수신 동작은 양방향이지만 브라우저에서는 클라이언트가 먼저 보내야 시작   
   
클라이언트가 시퀀스 번호와 데이터를 보낸다 ->   
서버는 송신 확인의 ACK 번호를 반송한다 ->   
...   
서버에서도 시퀀스 번호와 데이터를 클라이언트에 보내면 ->   
클라이언트는 송신 확인의 ACK 번호를 반송한다   

    4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다
ACK 번호가 돌아오기를 기다리는 시간을 '타임아웃 값'이라고 한다.   
이 값은 패킷의 평균 왕복 시간을 토대로 동적으로 조정한다.   
왕복 시간이 지연되면 대기 시간도 늘리고, 곧바로 돌아오면 대기 시간도 짧아진다.  

    5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다
한 개의 패킷을 보내고 ACK 번호를 기다리는 것은 시간 낭비이므로 윈도우 제어 방식을 사용.   
ACK 번호를 기다리지 않고 수신 측의 능력을 감안해 차례로 패킷을 보냄.  
수신 측에서 송신측에 수신 가능한 데이터 양을 통지. 이것을 윈도우 사이즈라고 부름.   
   
윈도우 사이즈가 4,380byte라고 통지하면 송신측은 그 값을 저장   
송신측이 데이터를 1,460byte 보내면 현재 윈도우 사이즈에 그 값을 뺀 2,920을 저장   
윈도우 사이즈가 0이 되면 송신 중지   
   
수신 측에서 2,900 byte만큼 데이터를 추출해 수신 버퍼에 빈 부분이 생기면    
그 분량만큼 TCP 헤더의 윈도우 필드에 이 값을 알림. 윈도우 사이즈는 2,920이 됨.  
다시 데이터 송신 시작.

    6. ACK 번호와 윈도우를 합승한다
윈도우 통지와 ACK 번호 통지는 한 패킷에 합승시켜 패킷 수를 줄일 수 있다.   
ACK 번호 통지가 연속으로 일어나는 경우 최후의 것만 통지해 패킷 수를 줄일 수도 있다.   
마찬가지로 윈도우 통지의 연속도 최후의 것만 통지할 수 있다.

    7. HTTP 응답 메시지를 수신한다
브라우저의 리퀘스트 메시지 송신 의뢰가 끝나면 서버에서 돌아오는 응답 메시지를 받기 위해 read 프로그램을 호출한다.   
메시지 수신 동작은 데이터 송신과 거의 유사.

## 4 서버에서 연결을 끊어 소켓을 말소한다
    1. 데이터 보내기를 완료했을 때 연결을 끊는다
데이터 보내기를 완료한 쪽(서버 측이라고 가정)에서 연결 끊기 단계에 들어가기 위해 Socket의 close를 호출 ->   
프로토콜 스택이 TCP 헤더를 만들고 컨트롤 비트의 FIN 비트를 1로 설정해 송신. 서버 측 소켓에 연결 끊기 동작 기록 ->   
FIN이 1인 TCP 헤더가 도착하면 클라이언트 소켓에 연결 끊기 기록. 패킷 수신 알리기 위해 ACK 번호 반송 ->   
클라이언트 앱이 read 호출해 데이터를 가지러 오면 데이터 대신 서버가 보낸 데이터 수신 완료 사실을 알림 ->   
클라이언트도 close 호출, FIN 1 TCP 헤더 서버에 송신. 서버에서 ACK 번호 돌아오면 통신 끝.    

    2. 소켓을 말소한다
오동작을 막기 위해 일정 시간이 지난 후 소켓을 말소한다.

    3. 데이터 송수신 동작을 정리한다
접속 동작 -> 송수신 동작 -> 연결 끊기 동작 순으로 TCP 프로토콜에서 애플리케이션의 데이터 송수신 과정이 끝난다.
## 5 IP와 이더넷의 패킷 송수신 동작
    1. 패킷의 기본
패킷은 헤더와 데이터 두 부분으로 구성. 헤더에는 수신처를 나타내는 주소 등의 제어 정보, 데이터는 내용물   
패킷을 주고 받는 송신처와 수신처는 자주 입장이 바뀌기 때문에 명확히 구별하지 않고 '엔드노드'라고 부른다.   
   
패킷의 기본은 여러 패킷 통신 방식에 적합하다. TCP/IP는 기본에서 발전한 단계로,   
'라우터'와 '허브'라는 패킷 중계 장치에서 역할을 분담하며 패킷을 운반하기 때문이다.   
   
1번) 라우터가 목적지를 확인하여 다음 라우터를 나타낸다 => MAC 헤더(이더넷용 헤더)   
2번) 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착한다 => IP 헤더(IP용 헤더)   
   
MAC 헤더는 라우터에 도착할 때마다 다음 라우터의 MAC 주소를 바꿔 써주고    
IP 헤더는 처음 송신처의 목적지 IP를 기록하면 변경할 일이 없다.   

    2. 패킷 송수신 동작의 개요
IP는 패킷을 들여다 보지 않고 그 앞에 IP 헤더와 MAC 헤더를 추가한다.   
그러므로 패킷을 송수신하는 동작은 패킷의 역할에 상관 없이 모두 같다.   
송신할 때는 TCP -> IP(두 헤더를 붙임) -> LAN 어댑터(이더넷)이고 수신할 때는 역순이다.

    3. 수신처 IP 주소를 기록한 IP 헤더를 만든다
IP 헤더의 제어 정보는 1)수신처 IP 주소를 설정하는데 가장 중요하다. 스스로 판단하지 않고 앱이 TCP에 통지한 그대로 사용한다.   
2)송신처 IP 주소도 설정한다. 그러나 해당 송신처에 할당된 LAN 어댑터가 여러 개면 주소도 여러개이므로 판단해야 한다.   
라우터의 IP용 표, 경로표 또는 라우팅 테이블이라고 부르는 것을 사용해 IP 헤더의 송신처 IP 주소를 설정한다.   
3)프로토콜 번호라는 필드에도 값을 설정한다. 패킷의 내용물이 어디에서 의뢰받은 것인지 나타낸다.   
TCP에서 의뢰받았으면 06(16진수), UDP이면 17(16진수)이라는 식이다.

    4. 이더넷용 MAC 헤더를 만든다
이더넷은 TCP/IP 개념이 통용되지 않아 다른 구조로 패킷의 수신처를 파악한다. 그 때 사용하는 것이 MAC 헤더.   
MAC 헤더에는 수신처 MAC 주소, 송신처 MAC 주소, 이더 타입이 기록되어 있다.   
MAC 주소는 IP(32bit) 주소와는 다르게 48bit이다. 또 주소의 개념이 아니고 48bit를 하나의 값으로 생각한다.   
   
   
이더 타입은 IP 헤더의 프로토콜 번호와 비슷하다. 이더넷의 경우 이더 타입까지가 MAC 헤더이고 그 뒤로는 패킷의 내용물이라 생각한다.   
그 내용물이 무엇인지 이더 타입으로 나타낸다. IP 프로토콜은 0800(16진 표기), ARP 프로토콜은 0806(16진)의 식이다.   
송신처 MAC 주소는 LAN 어댑터의 MAC 주소를 설정한다. 여러 LAN 어댑터가 있을 때는 여러개 중 하나의 어댑터를 정하고 그 MAC 주소를 설정한다.   
수신처 MAC 주소는 다소 복잡하다. 패킷을 건네주게 될 상대의 MAC 주소를 기록해야 하는데 누구에게 건네줄 지 모르기 때문에 우선 상대를 찾아야 한다.

    5. ARP로 수신처 라우터의 MAC 주소를 조사한다
ㅁ

    6. 이더넷의 기본
ㅁ

    7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다
ㅁ

    8. 패킷에 3개의 제어용 데이터를 추가한다
ㅁ

    9. 허브를 향해 패킷을 송신한다
ㅁ

    10. 돌아온 패킷을 받는다
ㅁ

    11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다
ㅁ
## 6 UDP 프로토콜을 이용한 송수신 동작
    1. 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다
ㅁ

    2. 제어용 짧은 데이터
ㅁ

    3. 음성 및 동영상 데이터
ㅁ
