# 21 _ 빌트인 객체
JS 객체는 다음과 같이 크게 3개의 객체로 분류할 수 있다.   
- 표준 빌트인 객체 : ES 사양에 정의되었으며 전역 객체의 프로퍼티로서 제공된다. JS 실행 환경(브라우저 or Node)에 관계없이 언제나 사용할 수 있다.   
- 호스트 객체 : ES 사양에는 정의돼 있지 않지만 브라우저에서는 Web API, Node에서는 Node 고유의 API를 제공한다.   
- 사용자 정의 객체 : 위의 두 객체가 아닌 사용자가 직접 정의한 객체를 말한다.   
## 21.2 표준 빌트인 객체   
JS는 Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise,   
Reflect, Proxy, JSON, Error 등 40여 개의 표준 빌트인 객체를 제공한다.   
Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.   
생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를, 생성자가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.   
   
## 21.3 원시값과 래퍼(Wrapper) 객체
문자열이나 숫자, 불리언 등의 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 표준 빌트인 생성자 함수가 존재하는 이유는 무엇일까?   
const str = 'hello'; &nbsp; &nbsp; console.log(str.length) -> 처럼 원시값인 문자열이 마치 객체처럼 동작한다.   
원시값에 객체처럼 접근하면 JS 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 이 연관된 객체를 래퍼 객체라고 한다.   
   
래퍼 객체가 생성되면서 그 내부 슬롯인 [[String Data]]에 원시값인 문자열이 저장된다.   
프로퍼티 접근이나 메서드 호출이 끝나면 JS 엔진은 다시 원시 값으로 되돌리고 래퍼 객체는 쓸모가 없어져 가비지 콜렉팅의 대상이 된다.   
즉, 원시값이 존재하는데도 표준 빌트인 생성자 함수가 있는 것은 원시값에 대해 객체처럼 접근하기 위해서라고 할 수 있다.

## 21.4 전역 객체(global object)
전역 객체는 코드 실행 이전 JS 엔진에 의해 가장 먼저 생성되는 특수하고, 어떤 객체에도 속하지 않은 최상위 객체다.   
브라우저 환경에서는 window(또는 self, this, frame), Node 환경에서는 global이 전역 객체를 가리킨다.   
ES11에서는 브라우저와 Node 환경에서 가리키던 다양한 전역 객체 식별자를 globalThis로 통일했다.   
   
전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다. JS 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.    
브라우저에서는 DOM, BOM, Canvas, XMLHttpRequest, fetch 등을, Node에서는 Node 고유 API를 호스트 객체로 제공한다.   
var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.   
let이나 const로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 이들은 보이지 않는 개념적인 블록(23장 '실행 컨텍스트' 참고) 내에 존재하게 된다.
### 21.4.1 빌트인 전역 프로퍼티
- Infinity : 무한대를 나타내는 숫자 타입   
- NaN : 숫자가 아님을 나타내는 숫자 타입   
- undefined : 원시 타입   
### 21.4.2 빌트인 전역 함수
- isFinite : 인수가 유한수인지를 불리언 타입으로 반환   
- isNaN : 인수가 NaN인지를 불리언 타입으로 반환   
- parseFloat : 문자열 인수를 실수로 해석(parsing)하여 반환   
- parseInt : 문자열 인수를 정수로 해석하여 반환   
  - 두 번째 인수로 진법을 나타내는 기수(2~36)을 전달할 수 있다. 문자열을 해당 기수의 숫자로 해석하여 반환한다.   
  - 반환값은 언제나 10진수다. 기수를 생략하면 기수는 10진수가 된다.   
- encodeURI / decodeURI : URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.   
  - 이스케이프 처리는 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것이다.   
- encodeURIComponent / decodeURIComponent : URI의 구성 요소(component)를 인수로 전달받아 인코딩한다.   
  - 인수로 전달된 문자열을 URI의 구성 요소인 쿼리 스트링의 일부로 간주한다.   
  - 따라서 쿼리 스트링 구분자로 사용되는 = ? & 까지 인코딩한다.   
### 21.4.3 암묵적 전역(implicit global)
선언하지 않은 식별자에 값을 할당하면 JS 엔진이 전역 객체에 해당 식별자를 프로퍼티로 동적 생성한다.   
결국 해당 식별자는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작하는데 이러한 현상을 암묵적 전역이라 한다.   
하지만 해당 식별자는 전역 객체의 프로퍼티로 추가되었을 뿐 변수가 아니다. 즉, 변수 호이스팅은 발생하지 않는다.

# 22 _ this
## 22.1 this 키워드
this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다.   
this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.   
this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.   
## 22.2 함수 호출 방식과 this 바인딩
this 바인딩은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.   
주의할 것은 동일한 함수도 다양한 방식으로 호출할 수 있다는 것이다. 함수를 호출하는 방식에는 아래와 같은 4가지 방식이 있다.   
### 22.2.1 일반 함수 호출
기본적으로 this에는 전역 객체(window)가 바인딩된다.   
일반 함수로 호출된 모든 함수(중첩  함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.   
### 22.2.2 메서드 호출
메서드 내부의 this는 매서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다.   
### 22.2.3 생성자 함수 호출
생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다.   
### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출
이들 메서드는 모든 함수가 상속받아 사용할 수 있다.   
apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. 두 메서드는 기본적으로 동일한 기능을 수행한다.   
다만, apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달하고 call 메서드는 인수를 쉼표로 구분한 리스트 형식으로 전달하는 차이가 있다.    
두 메서드는 대표적으로 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하고 싶을 때 사용된다.   
ex) Array.prototype.slice.call(arguments);
  - 유사 배열 객체 arguments에 call을 사용함으로써 slice 같은 배열의 메서드를 사용할 수 있다.
   
bind 메서드는 함수를 호출하지 않고 this로 사용할 객체만 전달한다.   
bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결할 때 사용된다.   
ex) callback.bind(this)


